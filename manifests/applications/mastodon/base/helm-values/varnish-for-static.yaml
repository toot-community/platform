onload: 
  host: haproxy-onload.haproxy-onload.svc.cluster.local
  port: 8080
  
varnish:
  size: 256M
  removeResponseHeaders:
    - "x-amz-request-id" # hetzner
    - "x-debug-bucket" # hetzner
    - "x-rgw-object-type" # hetzner
    - "x-amz-id-2" # wasabi
    - "x-amz-meta-btime" # wasabi
    - "x-amz-meta-fl-original-last-modified" # wasabi
    - "x-amz-meta-mtime" # wasabi
    - "x-wasabi-cm-reference-id" # wasabi
    - "x-amz-replication-status" # wasabi
  purge:
    enabled: true
    requiredHeader: X-TC-Purge-Key
    requiredPassword: ThisIsNotVerySecret

  configuration: |
    |-
    vcl 4.1;
    
    # https://github.com/varnish/toolbox/tree/master/vcls/hit-miss
    include "hit-miss.vcl";

    import dynamic;
    import std;
    
    backend proxy {
      .host = "{{ .Values.onload.host }}";
      .port = "{{ .Values.onload.port }}";
    }
    
    acl ipv4_only { "0.0.0.0"/0; }
    acl trusted_proxies { "10.0.0.0"/16; }
    acl purge_clients {
        "188.245.120.181"/32; # tc-prod-worker-1
        "128.140.87.70"/32; # tc-prod-worker-2
        "91.99.94.115"/32; # tc-prod-worker-3
    }

    sub vcl_init {
        new d = dynamic.director(
            port = "{{ .Values.backend.port }}",
            ttl = 60s,
            via = proxy,
            whitelist = ipv4_only
        );
    }
    
    sub vcl_backend_fetch {
      set bereq.http.Host = "{{ .Values.backend.host }}";
    }
    
    sub vcl_deliver {
      # Remove headers that are not needed
      {{ range $header := .Values.varnish.removeResponseHeaders }}
        unset resp.http.{{ $header }};
      {{ end }}
    }
    
    sub vcl_recv {
      set req.backend_hint = d.backend("{{ .Values.backend.host }}");

      # Health check
      if (req.url == "/__health") {
        return (synth(200, "OK"));
      }
      
      {{- if .Values.varnish.purge.enabled -}}
      if (req.method == "PURGE") {
          if (client.ip ~ trusted_proxies && req.http.X-Forwarded-For) {
              if (!(std.ip(regsub(req.http.X-Forwarded-For, "^[ ]*([^, ]+).*", "\1"), "0.0.0.0") ~ purge_clients)) {
                  return (synth(403, "Forbidden"));
              }
          } else if (!(client.ip ~ purge_clients)) {
              return (synth(403, "Forbidden"));
          }
          
          if (req.http.{{ .Values.varnish.purge.requiredHeader }} != "{{ .Values.varnish.purge.requiredPassword }}") {
              return (synth(403, "Forbidden"));
          }

          return (purge);
      }
      {{- end -}}

      # Never cache large files (by extension)
      if (req.url ~ "\.(mp4|webm|mkv|avi|mov|zip|tar\.gz)$") {
        return (pass);
      }

      # Remove cookies and auth headers to increase cachability
      unset req.http.Cookie;
      unset req.http.Authorization;
    }
    
    sub vcl_backend_response {
        # bypass really big files (>50 MB)
        if (beresp.http.Content-Length &&
            std.integer(beresp.http.Content-Length, 0) > 50_000_000) {
            set beresp.uncacheable = true;
            return (deliver);
        }

        # treat all 2xx/3xx objects the same, regardless of Cache-Control
        set beresp.ttl   = 5m;      # enough to catch ~90 % of re-uses
        set beresp.grace = 30s;     # serve slightly stale while refreshing
        set beresp.keep  = 2m;      # hit-for-miss window (needs hit-miss.vcl)

        # short-lived caching for client errors
        if (beresp.status >= 400 && beresp.status < 500) {
            set beresp.ttl = 30s;
            return (deliver);
        }

        # slightly longer for origin errors (to shield flaps)
        if (beresp.status >= 500) {
            set beresp.ttl   = 60s;
            set beresp.grace = 2m;
            return (deliver);
        }
    }